// Generated by CoffeeScript 1.6.2
(function() {
  var Config, action, blindUp, createDeck, dealPlayersHands, gameStart, getActionPlayer, getInfo, getState, getTableInfo, intervalTime, join, level, playersCount, shuffleArray, shufflePlayers, state, structure, tables;

  Config = require('../config');

  tables = {};

  playersCount = 0;

  structure = Config.getStructure();

  intervalTime = Config.getIntervalTime();

  state = 'waiting';

  level = 0;

  join = function(name, key, socketId) {
    if (!tables[0] || tables[0].players.length < 10) {
      if (!tables[0]) {
        tables[0] = {};
      }
      if (!tables[0].players) {
        tables[0].players = [];
      }
      tables[0].players[tables[0].players.length] = {
        id: playersCount,
        name: name,
        key: key,
        socketId: socketId,
        isActive: false,
        win: null,
        tie: null,
        hand: []
      };
    }
    return playersCount += 1;
  };

  gameStart = function() {
    var bbPosition, i, sbPosition, stack, table, tableId, _i, _ref;
    level = 0;
    stack = Config.getStack();
    for (tableId in tables) {
      table = tables[tableId];
      table.players = [].concat(shufflePlayers(table.players));
      console.log('shuffled players = ' + table.players);
      table.dealerButton = Math.floor(Math.random() * table.players.length);
      table.playedHandCount = 0;
      table.actionCount = 0;
      table.lastBet = 0;
      table.pot = 0;
      table.playersNum = table.players.length;
      table.activePlayersNum = table.players.length;
      for (i = _i = 0, _ref = table.players.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        table.players[i].stack = stack;
      }
      sbPosition = (table.dealerButton + 1) % table.players.length;
      bbPosition = (table.dealerButton + 2) % table.players.length;
      table.pot += Number(structure[level] / 2);
      table.players[sbPosition].stack -= Number(structure[level] / 2);
      table.pot += structure[level];
      table.players[bbPosition].stack -= structure[level];
      dealPlayersHands(tableId);
      table.actionPlayerSeat = (table.dealerButton + 3) % table.players.length;
    }
    setTimeout(function() {
      return blindUp();
    }, intervalTime);
    return state = 'gaming';
  };

  getInfo = function() {
    var info, table, tableId;
    info = {
      state: state,
      level: level,
      tables: {}
    };
    for (tableId in tables) {
      table = tables[tableId];
      info.tables[tableId] = {
        pot: table.pot,
        lastBet: table.lastBet,
        dealerButton: table.dealerButton,
        playedHandCount: table.playedHandCount,
        playersNum: table.playersNum,
        activePlayersNum: table.activePlayersNum,
        players: table.players
      };
    }
    return info;
  };

  getState = function() {
    return state;
  };

  getTableInfo = function(tableId) {
    var key, player, tableInfo, _ref;
    tableInfo = {
      state: state,
      level: level,
      pot: tables[tableId].pot,
      lastBet: tables[tableId].lastBet,
      dealerButton: tables[tableId].dealerButton,
      playedHandCount: tables[tableId].playedHandCount,
      playersNum: tables[tableId].playersNum,
      activePlayersNum: tables[tableId].activePlayersNum,
      players: []
    };
    _ref = tables[tableId].players;
    for (key in _ref) {
      player = _ref[key];
      tableInfo.players[key] = {
        name: player.name,
        stack: player.stack,
        isActive: player.isActive
      };
    }
    return tableInfo;
  };

  getActionPlayer = function(tableId) {
    return tables[tableId].players[tables[tableId].actionPlayerSeat];
  };

  action = function(data, callback) {
    var actionPlayerSeat, amount, key, player, playerSeat, tableId, winPlayerSeat, _ref;
    key = data.key;
    action = data.action;
    amount = data.amount;
    tableId = 0;
    if (key === tables[tableId].players[tables[tableId].actionPlayerSeat].key) {
      actionPlayerSeat = tables[tableId].actionPlayerSeat;
      switch (action) {
        case 'fold':
          tables[tableId].players[actionPlayerSeat].isActive = false;
          tables[tableId].activePlayersNum -= 1;
          if (tables[tableId].activePlayersNum === 1) {
            winPlayerSeat = 0;
            _ref = tables[tableId].players;
            for (playerSeat in _ref) {
              player = _ref[playerSeat];
              if (player.isActive === true) {
                winPlayerSeat = playerSeat;
              }
            }
            tables[tableId].players[winPlayerSeat].stack += tables[tableId].pot;
            callback({
              status: 'ok',
              message: 'got fold.',
              sentTableAll: tables[tableId].players[winPlayerSeat].name + ' takes pot ' + tables[tableId].pot
            });
          } else {
            console.log('go to next hand');
          }
          break;
        case 'call':
          tables[tableId].pot += tables[tableId].lastBet;
          tables[tableId].players[actionPlayerSeat].stack -= tables[tableId].lastBet;
          callback({
            status: 'ok',
            message: 'got call.'
          });
          break;
        case 'raise':
          if (amount < tables[tableId].lastBet * 2) {
            amount = tables[tableId].lastBet * 2;
          }
          tables[tableId].pot += amount;
          tables[tableId].players[actionPlayerSeat].stack -= amount;
          callback({
            status: 'ok',
            message: 'got raise ' + amount
          });
      }
      return tables[tableId].actionPlayerSeat += 1;
    } else {
      return callback('ignroe');
    }
  };

  module.exports = {
    join: join,
    getInfo: getInfo,
    gameStart: gameStart,
    getState: getState,
    getTableInfo: getTableInfo,
    getActionPlayer: getActionPlayer,
    action: action
  };

  blindUp = function() {
    level += 1;
    return setTimeout(function() {
      return blindUp();
    }, intervalTime);
  };

  dealPlayersHands = function(tableId) {
    var cardPosition, i, key, value, _i, _ref;
    tables[tableId].deck = [].concat(createDeck());
    for (i = _i = 0; _i < 2; i = ++_i) {
      _ref = tables[tableId].players;
      for (key in _ref) {
        value = _ref[key];
        cardPosition = Math.floor(Math.random() * tables[tableId].deck.length);
        tables[tableId].players[key].hand[i] = tables[tableId].deck[cardPosition];
        tables[tableId].deck.splice(cardPosition, 1);
        tables[tableId].players[key].isActive = true;
      }
    }
    return console.log('check it!');
  };

  createDeck = function() {
    var trumps;
    trumps = ['As', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s', 'Ts', 'Js', 'Qs', 'Ks', 'Ah', '2h', '3h', '4h', '5h', '6h', '7h', '8h', '9h', 'Th', 'Jh', 'Qh', 'Kh', 'Ad', '2d', '3d', '4d', '5d', '6d', '7d', '8d', '9d', 'Td', 'Jd', 'Qd', 'Kd', 'Ac', '2c', '3c', '4c', '5c', '6c', '7c', '8c', '9c', 'Tc', 'Jc', 'Qc', 'Kc'];
    return shuffleArray(trumps);
  };

  shuffleArray = function(targetArray) {
    var i, j, length, t, _i, _j, _len, _ref, _results;
    length = targetArray.length;
    _ref = (function() {
      _results = [];
      for (var _j = 0; 0 <= length ? _j < length : _j > length; 0 <= length ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this) in targetArray;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      j = Math.floor(Math.random() * length);
      t = targetArray[i];
      targetArray[i] = targetArray[j];
      targetArray[j] = t;
    }
    return targetArray;
  };

  shufflePlayers = function(players) {
    var i, j, length, t, _i, _j, _len, _ref, _results;
    length = players.length;
    _ref = (function() {
      _results = [];
      for (var _j = 0; 0 <= length ? _j < length : _j > length; 0 <= length ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this) in players;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      j = Math.floor(Math.random() * length);
      t = new players[i].constructor();
      players[i] = new players[j].constructor();
      players[j] = new t.constructor();
    }
    return players;
  };

}).call(this);
